---
alwaysApply: true
---

# Smart Stream Project Rules

## Project Overview
Smart Stream is a **Home Assistant Add-on** for streaming IP cameras to platforms like YouTube. This is a modern TypeScript/React/Node.js application.

## Architecture & Technology Stack

### **Monorepo Structure (pnpm)**
- `packages/shared` - **@smart-stream/shared** - Shared TypeScript types and utilities
- `apps/backend` - **@smart-stream/backend** - Express.js API server with TypeScript
- `apps/frontend` - **@smart-stream/frontend** - React SPA with Vite and Tailwind CSS

### **Core Technologies**
- **Backend**: TypeScript + Express.js + node-json-db + Zod + ONVIF + FFmpeg
- **Frontend**: React 18 + TypeScript + Vite + Tailwind CSS + React Router
- **Shared**: TypeScript types for API contracts and data models
- **Package Manager**: pnpm with workspace configuration
- **Container**: Docker (Home Assistant Add-on)

### **Key Dependencies**
- **Validation**: Zod for runtime type checking and API validation
- **UI**: Tailwind CSS with custom component classes + React Hot Toast for notifications
- **Icons**: Lucide React for consistent iconography
- **HTTP Client**: Axios with interceptors for API communication
- **Camera Protocol**: ONVIF for IP camera discovery, stream URI detection, and control
- **Streaming**: FFmpeg via @ffmpeg-installer/ffmpeg for cross-platform video processing
- **Logging**: Debug module for structured, conditional logging across services

## Development Principles

### **Type Safety First**
- Strict TypeScript configuration across all packages
- Shared types in `@smart-stream/shared` ensure API contract consistency
- Zod schemas for runtime validation of external data
- No `any` types - prefer proper interfaces and type definitions

### **Monorepo Workflow**
- Use workspace dependencies (`workspace:*`) for internal packages
- Build shared types first: `pnpm shared:build`
- Parallel build: `pnpm build` builds all apps (use this command to validate changes)

### **Code Organization**
- **Backend**: Service-oriented architecture with clear separation of concerns
- **Frontend**: Component-driven development with custom hooks
- **Shared**: Domain-specific type organization (camera, stream, config, api)
- **Configuration**: TypeScript configs extend from strict base configurations

### **API Design**
- RESTful endpoints with consistent response format (`ApiResponse<T>`)
- Versioned API (`/api/v1/`) for future compatibility
- Comprehensive error handling with typed error responses
- Input validation with Zod schemas and middleware

### **UI/UX Standards**
- Responsive design with mobile-first approach
- Consistent component library using Tailwind utility classes
- Toast notifications for user feedback
- Loading states and error boundaries for better UX

## Development Commands

### **Essential Workflows**
```bash
# Build all packages
pnpm build

# Type checking
pnpm type-check
```

### **Code Quality**
```bash
# Linting
pnpm lint

# Formatting
pnpm format

# Type checking specific package
pnpm --filter @smart-stream/backend type-check
```

## Project Constraints & Context

### **Home Assistant Integration**
- Must work within Home Assistant Add-on container environment
- Configuration via `config.json` (Home Assistant standard)
- No external authentication needed (HA handles access control)
- Data persistence in `/data` directory

### **Camera Support**
- **ONVIF Integration**: Camera discovery, stream URI detection, and connection testing
- **RTSP Protocols**: Dynamic URL construction with TCP transport for reliability
- **Credential Management**: Secure storage and authenticated RTSP connections
- **Auto-discovery**: Network scanning for ONVIF-enabled cameras
- **Autostart Configuration**: Per-camera automatic stream startup on app launch

### **Streaming Capabilities**
- **Platform Support**: YouTube Live, Twitch, and custom RTMP endpoints
- **Video Processing**: FFmpeg copy mode for zero-transcoding performance
- **RTSP Discovery**: Dynamic RTSP URL detection via ONVIF for camera compatibility
- **Autostart Streams**: Automatic stream initialization for configured cameras
- **Real-time Monitoring**: Live stream statistics, progress tracking, and error detection
- **Credential Security**: Safe handling of camera credentials in RTSP URLs

## File Naming & Structure Conventions

### **TypeScript Files**
- PascalCase for components and services: `CameraService.ts`, `Dashboard.tsx`
- camelCase for utilities and hooks: `useHealthCheck.ts`, `apiClient.ts`
- Descriptive names that indicate purpose and domain

### **Directory Organization**
- Group by feature/domain rather than file type
- Shared utilities in appropriate service/utility directories
- Keep related files close together (component + types + hooks)

### **Import/Export Patterns**
- Use `@smart-stream/shared` for cross-package type imports
- Path aliases: `@/` for relative imports within packages
- Named exports preferred over default exports for better tree-shaking
- Re-export from index files for clean public APIs

## Error Handling & Validation

### **Backend Error Strategy**
- Custom error classes: `ValidationError`, `CameraNotFoundError`, `StreamError`
- Structured error responses with error codes and details
- Comprehensive error middleware with request context
- Graceful degradation for non-critical failures

### **Frontend Error Strategy**
- Error boundaries for component-level error catching
- Toast notifications for user-facing errors
- Loading states during async operations
- Fallback UI for failed data loads

### **Validation Strategy**
- Zod schemas for API input validation
- TypeScript interfaces for compile-time type checking
- Runtime validation for external data (camera configs, API responses)
- Clear error messages for validation failures

## Performance & Optimization

### **Build Optimization**
- TypeScript strict mode for better compiler optimizations
- Vite for fast frontend builds and HMR
- pnpm for efficient dependency management
- Incremental builds with workspace dependencies

### **Runtime Performance**
- **Zero-Transcoding**: FFmpeg copy mode preserves quality and minimizes CPU usage
- **Optimized Logging**: Structured debug logging with configurable verbosity levels
- **Stream Efficiency**: Real-time monitoring with minimal overhead
- **React Optimization**: Component memoization and efficient state management
- **Database**: Lightweight JSON-based storage optimized for camera configurations

---

## Key Technical Implementation Notes

### **FFmpeg Integration**
- Use @ffmpeg-installer/ffmpeg for cross-platform binary distribution
- Prefer copy mode (-c:v copy) over transcoding for performance
- Implement null audio source (-f lavfi -i anullsrc) for video-only streams
- Use structured args with proper escaping for RTSP credentials

### **ONVIF Best Practices**
- Use getStreamUri() callback pattern for real camera URL discovery
- Implement fallback to constructed RTSP URLs when ONVIF fails
- Test connections before adding cameras to prevent configuration errors

### **Streaming Architecture**
- Autostart cameras on application initialization after services are ready
- Support multiple platforms (YouTube/Twitch) with per-camera configuration
- Implement comprehensive error detection and recovery mechanisms
- Use debug module for clean, conditional logging across all services

## Notes for AI Assistance
- Prioritize TypeScript solutions with strict typing
- Follow established service patterns and error handling
- Use workspace packages for shared functionality
- Maintain Tailwind utility class consistency
- Consider Home Assistant Add-on deployment constraints
- Test FFmpeg commands thoroughly across different camera types
